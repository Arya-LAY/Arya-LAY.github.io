<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/2023/12/04/zu-hui/"/>
      <url>/2023/12/04/zu-hui/</url>
      
        <content type="html"><![CDATA[<p>今天组会，我介绍自己近期的工作的想法和进展情况。</p><p>我研究内容的主题是，在线性传感网络中，设计实现一种自适应的节点睡眠或唤醒调度方法。自适应的意思是指，网络中的每一个节点，根据自己所处的位置，以及当前网络中的流量情况，自行决定自己在接下来的时隙中是处于睡眠状态还是活跃状态。我给该方案起了一个名字，叫做SA-SWS，SA对应自适应，SWS对应睡眠唤醒调度。</p><p>评估一个网络性能主要的参数有：数据包的时延和到达率。考虑到传感器网络的特殊之处，也就是单个传感器节点的能量十分有限，那评估网络性能的参数还要再加上节点的能量消耗情况。</p><p>节点的睡眠唤醒调度方法是无线传感网络中一个基本的问题，是为了在不牺牲或者适量牺牲网络性能的情况下，尽可能使节点保持在睡眠状态中，以节省节点的能量，最大化网络的生命周期。</p><p>最先开始出现的是占空比技术。也就是调整节点活跃时间与睡眠时间的占比。所有节点周期性的在两种状态之间进行切换。这种方法显著的减少了节点的能量消耗，不过也会带来新的问题。第一个是占空比大小，如果固定一个值，显然不适合实际情况。第一篇文章就是动态调整占空比，它首先先调查当前占空比是如何影响网络时延的。然后增大非热门节点的占空比，充分的使用剩余的能量。这样在不影响网络生命周期的情况下，减小时延。</p><p>占空比面临的第二个问题是网络会有比较大的睡眠时延，当有数据到达一个节点时，如果节点现在节点处于睡眠状态，那么数据只能等待，直到节点切换到活跃状态。这样一跳一跳的累积下来，增大整体的时延。文章2就是针对睡眠时延，提出流水线式的数据传输技术。将相邻节点之间的活跃状态串开，上一跳节点将数据发送完毕，下一跳节点刚好进入活跃状态。该方案在减小睡眠时延的同时还能避免干扰。</p><p>占空比技术实现是以时间同步技术为基础的。关于占空比的论文中，都是假定不考虑时钟同步。但实际上，这是一个不可避免地问题。因为无论将占空比技术设计成什么样，都需要节点之间在时间上的同步和配合。暂且不谈时钟同步技术上的难度，节点之间为此付出的代价也会对网络性能有影响。</p><p>还有一类方法，跳出了这个圈子。不让节点统一行动，而且自行调整行为。第三篇文章就是这样，自适应的方式让节点免于在能量与占空比之间进行权衡，也不用依赖时钟同步技术。且在不与邻居节点通信的情况下，猜测邻居节点的行为，然后与之配合。简单来说，有数据到来，节点就切换到活跃状态，没有数据到来，节点就睡眠。那怎么预测有没有数据包到来呢，这是本文研究解决的问题，一会详细的讲述。</p><h1 id="前三篇文章的出发点是节点能量有限，且不能再充电或者更换电池。但是最近几年出出现可以收集能量的传感器节点。第4-篇文章就是研究移动的传感器节点怎么找到合适的轨迹来兼顾充电和数据传输。-begin-Bmatrix-1-1-1-0-0-0-end-Bmatrix-begin-Bmatrix-α1-β1-γ1-end-Bmatrix"><a href="#前三篇文章的出发点是节点能量有限，且不能再充电或者更换电池。但是最近几年出出现可以收集能量的传感器节点。第4-篇文章就是研究移动的传感器节点怎么找到合适的轨迹来兼顾充电和数据传输。-begin-Bmatrix-1-1-1-0-0-0-end-Bmatrix-begin-Bmatrix-α1-β1-γ1-end-Bmatrix" class="headerlink" title="前三篇文章的出发点是节点能量有限，且不能再充电或者更换电池。但是最近几年出出现可以收集能量的传感器节点。第4 篇文章就是研究移动的传感器节点怎么找到合适的轨迹来兼顾充电和数据传输。$$\begin{Bmatrix} &amp; &amp; \ +1 &amp;-1&amp;-1\ 0&amp;0&amp;0\end{Bmatrix}*\begin{Bmatrix}α1\β1\γ1\end{Bmatrix}"></a>前三篇文章的出发点是节点能量有限，且不能再充电或者更换电池。但是最近几年出出现可以收集能量的传感器节点。第4 篇文章就是研究移动的传感器节点怎么找到合适的轨迹来兼顾充电和数据传输。<br>$$<br>\begin{Bmatrix}<br> &amp; &amp; \<br> +1 &amp;-1&amp;-1\<br> 0&amp;0&amp;0<br>\end{Bmatrix}<br>*<br>\begin{Bmatrix}<br>α1\<br>β1\<br>γ1<br>\end{Bmatrix}</h1><p>\begin{Bmatrix}<br>Qtable[ ][0]\<br>Qtable[][1]\<br>Qtable[ ][2]<br>\end{Bmatrix}</p><h1 id="begin-Bmatrix-1-1-1-0-0-0-end-Bmatrix-begin-Bmatrix-α2-β2-γ2-end-Bmatrix"><a href="#begin-Bmatrix-1-1-1-0-0-0-end-Bmatrix-begin-Bmatrix-α2-β2-γ2-end-Bmatrix" class="headerlink" title="\begin{Bmatrix} +1&amp; +1&amp;-1\  &amp; &amp; \ 0&amp;0&amp;0\end{Bmatrix}*\begin{Bmatrix}α2\β2\γ2\end{Bmatrix}"></a>\begin{Bmatrix}<br> +1&amp; +1&amp;-1\<br>  &amp; &amp; \<br> 0&amp;0&amp;0<br>\end{Bmatrix}<br>*<br>\begin{Bmatrix}<br>α2\<br>β2\<br>γ2<br>\end{Bmatrix}</h1><p>\begin{Bmatrix}<br>Qtable[ ][0]\<br>Qtable[][1]\<br>Qtable[ ][2]<br>\end{Bmatrix}<br>$$</p><p>本文的motivation有3点</p><p>第一点是改进了ye教授的方法，就是前面第三篇文献，原来的方案是用于网状2维的网络。而线性传感网络有自身的特点和应用场景。将ye教授的方案直接部署的话，效果不是很好。我做的工作是将方案调整到适合线性传感器网络中。</p><p>在改进之后，不仅与场景比较合适，方案的性能优于简单的占空比方案。且不需要时钟同步技术的加持解决了之前的一个痛点。</p><p>最后，为了缓解线性传感器网络的能量空洞问题，部署了冗余节点测试协议的性能。此外，在双联中考虑同级碰撞，并对冗余节点的个数与碰撞的激烈程度做了一点讨论。</p><p>整体的方案是基于强化学习的，智能体以试错的方式，选择动作，环境会进入到下一个状态，并对该动作给出奖励。智能体的目的就是学习出最优的动作序列。本方案的状态集合是s0到s3，数字代表节点待发送的数据包的个数。如果目前节点内已经有了3个数据包，如果还有新的数据包到达，就删除最先进入队列的数据，将新数据入列。动作集合包含传输，监听，睡眠。传输可以接收和发送数据，监听可以接收数据，睡眠都不可以。在能量消耗上，传输最多，睡眠最少前两种动作执行成功的奖励是正1，失败是－1，成功与否的标志是有无ACK。每一个节点都会维护两个表格。一个是执行动作的策略，policy，代表在某一状态下执行某一动作的概率。另一个表格是Q值表，与获得奖励对应，是payoff的函数。每一次迭代都会更新这两个表格的某一个值。把每一个动作持续的时间叫做一个时隙。发送一个数据包或者接收一个数据包所消耗的时间是一个微时隙的大小，这里设置为2ms。一个完整的时隙大小是8ms.每经过一个时隙，都要迭代一次算法。</p><p>整个算法的流程是：进入一个新的时隙时，先选择在这个时隙要执行的动作，动作结束后，节点内的数据包个数可能会有变化，状态也跟着变化。依据通信的情况，计算奖励，更新Q表。最后2步比较重要。传感器节点会分别预测上下两条节点执行动作的策略，对邻居策略的策略并不区分状态，单看每个动作的概率情况。至于怎么预测一会再说。预测结束后就进入到下一个时隙。学习率会有细微的减小，为了使算法尽快收敛。下一个时隙就根据policy在继续选择新动作。对原算法的改进集中在两点上，第一个是使用确定性的从策略中选择策略。以前是按照概率比例选择，现在直接选择概率最大的。因为数据是按指数到达的，网络中的流量周期循环的那种稳定。如果网络流量是完全随机，那就应该用之前那种选择方法，保留动作的随机性。</p><p>第二个改进点同时计算上下两个节点的policy。假设现在已经计算完，两个节点的动作概率。字母代表3个节点各动作概率。α1到γ1，α2到γ2全是已知的。更新本节点的policy的依据是这3个关系，当下一跳节点的传输和监听时，对应本节点的是传输，因为这样通信才能传输成功。当上一跳的传输，对应本节点的传输和监听，这也是为了通信能成功，节点可以获得正奖励。剩下的就是睡眠的概率。</p><p>到这里大家有什么问题吗</p><p>接下来是计算两个节点的policy。先填入这个奖励矩阵，举例解释一下当中的值是怎么计算的。写道下面就是这两个3x3的矩阵。空白的部分要看下下个节点了，本节点不考虑了。奖励矩阵×上一跳节点每个动作的奖励=本节点对应动作所获得Q值，Q值也是正负奖励累积过来的。缺一行的用概率和=1补上，这样就能解出来α1，β1，γ1的值了。同样的方法也解出。。。</p><p>下面是关于冗余节点和碰撞场景的设计。传感器节点是既可以感知环境生成数据又可以转发上游节点的数据。冗余节点只能转发数据。假设这个图里没有冗余节点，数据横向传输到汇聚节点，那越靠近汇聚节点的传感器消耗的能量就越快，会先于其他节点将能量耗尽，也就是能量空洞。部署冗余节点就是为了缓解能量空洞问题。</p><p>policy的更新，也就是节点的动作，实际上是随着网络中的流量变化而变化的。传感器节点因为既有从上游接收的数据，又有向下游发送自己的数据，所以我让他计算上下跳两个节点的行为。冗余节点是只有上游有数据到来，所以只计算上一跳的行为。</p><p>考虑碰撞的时候，如果有下面这种双链的情形，引入碰撞。红色的线代表 碰撞消息的传递，蓝色的线代表正常的消息传递。当第一个节点和第5个节点在同一微时隙发送数据时，节点会同时受到两个数据，所以产生碰撞，造成通信失败。这时候会返回一个碰撞提示，这意味着对第一个节点来说，在这个时隙内选择传输动作是对的，但是选择的这个微时隙是不对的。所以传输动作会对应正奖励，但是会对那个微时隙给一个负奖励。这样两个节点当中就会有一个做出避让。最后达到避免碰撞的目的。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/12/04/48-stdvector-shi-yong-you-hua/"/>
      <url>/2023/12/04/48-stdvector-shi-yong-you-hua/</url>
      
        <content type="html"><![CDATA[<h1 id="48-std-vector使用优化"><a href="#48-std-vector使用优化" class="headerlink" title="48 std::vector使用优化"></a>48 std::vector使用优化</h1><p>优化时，应该首先知道当你执行一个操作时，到底是怎么发生的，每一步是怎样工作的。</p><h3 id="push-back-函数"><a href="#push-back-函数" class="headerlink" title="push_back()函数"></a><code>push_back()</code>函数</h3><p>当向容器中增加元素时，如果原来分配的内存不够大，就会重新分配另一块更大的新的内存。将原来的旧元素复制过来。这是拖慢速度的主要因素之一。</p><p>优化的思路之一，尽量避免复制操作。尤其是使用Vector时。</p><p>调用构造函数的次数</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Vertex</span></span><br><span class="line">{</span><br><span class="line"><span class="type">int</span> x, y, z;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Vertex</span>(<span class="type">float</span> X, <span class="type">float</span> Y, <span class="type">float</span> Z)</span><br><span class="line">:<span class="built_in">x</span>(X), <span class="built_in">y</span>(Y), <span class="built_in">z</span>(Z)</span><br><span class="line">{}</span><br><span class="line"></span><br><span class="line"><span class="built_in">Vertex</span>(<span class="type">const</span> Vertex&amp; vertices)                             <span class="comment">//拷贝构造函数</span></span><br><span class="line">:<span class="built_in">x</span>(vertices.x), <span class="built_in">y</span>(vertices.y), <span class="built_in">z</span>(vertices.z)</span><br><span class="line">{</span><br><span class="line">std::cout &lt;&lt; <span class="string">"Copied!"</span> &lt;&lt; std::endl;</span><br><span class="line">}</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>一共调用了6次构造函数。</p><p>第一次：在<code>main</code>中构造一个<code>Vertex(1,2,3</code>); 然后复制到了<code>Vertices</code>中。</p><p><strong>这里是优化的第一种方法：直接在Vector那个内存中构建元素。</strong></p><p>第2、3次：创建<code>Vertex(4,5,6)</code>，复制进<code>Vector</code>中复制一次。调整<code>vector</code>的大小，将元素1又复制了一次。</p><p>第4、5、6次：创建<code>Vertex(7,8,9)</code>，复制进Vector中复制一次。调整<code>vector</code>的大小，将元素1，2又复制了一次。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;Vertex&gt;vertices;</span><br><span class="line"></span><br><span class="line">vertices.<span class="built_in">push_back</span>(<span class="built_in">Vertex</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> ));    </span><br><span class="line">vertices.<span class="built_in">push_back</span>(<span class="built_in">Vertex</span>(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>));</span><br><span class="line">vertices.<span class="built_in">push_back</span>(<span class="built_in">Vertex</span>(<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>));</span><br></pre></td></tr></tbody></table></figure><p><strong>第二种优化策略：如果提前知道Vector大小，就可以避免后续的大小调整，而带来的复制。</strong></p><p>reserve()函数设置容器大小。下面的代码目前仅有3次复制构造函数的调用。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;Vertex&gt;vertices;</span><br><span class="line">vertices.<span class="built_in">reserve</span>(<span class="number">3</span>);              <span class="comment">//预先设置大小</span></span><br><span class="line">vertices.<span class="built_in">push_back</span>(<span class="built_in">Vertex</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> ));    </span><br><span class="line">vertices.<span class="built_in">push_back</span>(<span class="built_in">Vertex</span>(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>));</span><br><span class="line">vertices.<span class="built_in">push_back</span>(<span class="built_in">Vertex</span>(<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>));</span><br></pre></td></tr></tbody></table></figure><p><strong>使用第一种优化策略</strong></p><p>直接在<code>Vector</code>的内存中创建对象。</p><p><code>emplace_back()</code></p><p>这是使用参数列表创建对象，代表告诉编译器，在<code>Vector</code>的内存中，用以下参数直接创建对象。此时，已经不会再调用拷贝构造函数了。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;Vertex&gt;vertices;</span><br><span class="line">vertices.<span class="built_in">reserve</span>(<span class="number">3</span>);</span><br><span class="line">vertices.<span class="built_in">emplace_back</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> );    </span><br><span class="line">vertices.<span class="built_in">emplace_back</span>(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line">vertices.<span class="built_in">emplace_back</span>(<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>);</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/12/04/47-dong-tai-shu-zu-vector-in-c/"/>
      <url>/2023/12/04/47-dong-tai-shu-zu-vector-in-c/</url>
      
        <content type="html"><![CDATA[<h1 id="47-动态数组vector-in-C"><a href="#47-动态数组vector-in-C" class="headerlink" title="47 动态数组vector in C++"></a>47 动态数组vector in C++</h1><h3 id="标准模板库STL，包含很多容器，模板化，可以自己觉得容器中的数据类型"><a href="#标准模板库STL，包含很多容器，模板化，可以自己觉得容器中的数据类型" class="headerlink" title="标准模板库STL，包含很多容器，模板化，可以自己觉得容器中的数据类型"></a>标准模板库<code>STL</code>，包含很多容器，模板化，可以自己觉得容器中的数据类型</h3><h2 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h2><p>在std命名空间中</p><p>动态数组，数组大小是可变的。创建时可以不指定大小。</p><p>实际上以向量<code>vector</code>命名是不太合适的，<code>ArrayList</code>更合理一些。</p><p>速度不是标准模板库优先考虑的东西，因此许多团队会写自己的模板库，比如<code>EASTL</code>，这个是开源的。</p><h3 id="Vector-工作方式"><a href="#Vector-工作方式" class="headerlink" title="Vector 工作方式"></a>Vector 工作方式</h3><p>添加数据时，会改变大小。每当向数组中添加数据时，会在内存中新开辟一块比原来大的区域，把原来的Vector复制过来，填上新数据，再删除旧的Vector。</p><h3 id="Vector最好存储的是对象"><a href="#Vector最好存储的是对象" class="headerlink" title="Vector最好存储的是对象"></a>Vector最好存储的是对象</h3><p>在创建<code>Vector</code>, 指定数据类型时，可以指定类类型，也可以指定类指针类型。</p><p>指定类类型，存储的是对象。这种存储方式优于类指针。因为当存储对象是，Vector中的数据是在条线上的，各个对象是挨着的。当遍历，赋值时速度更快。存储类指针时，放到一起的是指针，数据可能在内存中的各个地方。另一方面，当增加新数据时，第一种方式要复制所有的数据，第二中方式只需复制指针。</p><p>但无论如何，指针形式都不是优先考虑的。只有在必须使用是才使用。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Vertex</span></span><br><span class="line">{</span><br><span class="line"><span class="type">int</span> x, y, z;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">std::ostream&amp; <span class="keyword">operator</span> &lt;&lt; (std::ostream&amp; stream,<span class="type">const</span> Vertex&amp; vertices)   <span class="comment">//重载 &lt;&lt;</span></span><br><span class="line">{</span><br><span class="line">stream &lt;&lt; vertices.x &lt;&lt;<span class="string">","</span>&lt;&lt; vertices.y &lt;&lt;<span class="string">","</span>&lt;&lt; vertices.z;</span><br><span class="line"><span class="keyword">return</span> stream;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="添加遍历数据"><a href="#添加遍历数据" class="headerlink" title="添加遍历数据"></a>添加遍历数据</h3><p>添加元素函数：<code>push.back()</code></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;Vertex&gt;vertices;</span><br><span class="line"></span><br><span class="line">vertices.<span class="built_in">push_back</span>({ <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> });    <span class="comment">//初始化列表</span></span><br><span class="line">vertices.<span class="built_in">push_back</span>({ <span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span> });</span><br></pre></td></tr></tbody></table></figure><p>遍历函数</p><p>第一种遍历用了重载过的<code>&lt;&lt;</code>符号，一般可以自己写一个<code>print()</code>函数。</p><p>第二种遍历是范围<code>for</code>语句<code>，c++11</code>中新的方法。为了避免复制，应该使用引用&amp;。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; vertices.<span class="built_in">size</span>(); i++)</span><br><span class="line">    std::cout &lt;&lt; vertices[i] &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">const</span> Vertex&amp; v:vertices)</span><br><span class="line">    std::cout &lt;&lt; v&lt;&lt; std::endl;</span><br></pre></td></tr></tbody></table></figure><h3 id="删除某个元素"><a href="#删除某个元素" class="headerlink" title="删除某个元素"></a>删除某个元素</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除第2个元素,不能直接写2</span></span><br><span class="line">vertices.<span class="built_in">erase</span>(vertices.<span class="built_in">begin</span>() + <span class="number">1</span>);</span><br></pre></td></tr></tbody></table></figure><h3 id="清空整个数组"><a href="#清空整个数组" class="headerlink" title="清空整个数组"></a>清空整个数组</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vertices.<span class="built_in">clear</span>()</span><br></pre></td></tr></tbody></table></figure><h3 id="当容器作为函数参数传入时，一定要引用传入"><a href="#当容器作为函数参数传入时，一定要引用传入" class="headerlink" title="当容器作为函数参数传入时，一定要引用传入"></a>当容器作为函数参数传入时，一定要引用传入</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Function</span><span class="params">(<span class="type">const</span> std::vector&lt;Vertex&gt;&amp; vertices)</span>     <span class="comment">//引用传入参数</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">std::vector&lt;Vertex&gt;vertices;</span><br><span class="line"></span><br><span class="line">vertices.<span class="built_in">push_back</span>({ <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> });    <span class="comment">//初始化列表</span></span><br><span class="line">vertices.<span class="built_in">push_back</span>({ <span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span> });</span><br><span class="line"></span><br><span class="line"><span class="built_in">Function</span>(vertices);</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/12/04/46-jian-tou-cao-zuo-fu-in-c/"/>
      <url>/2023/12/04/46-jian-tou-cao-zuo-fu-in-c/</url>
      
        <content type="html"><![CDATA[<h1 id="46-箭头操作符-in-C"><a href="#46-箭头操作符-in-C" class="headerlink" title="46 箭头操作符 in C++"></a>46 箭头操作符 in C++</h1><h2 id="用法一：代替解引用和-操作符。"><a href="#用法一：代替解引用和-操作符。" class="headerlink" title="用法一：代替解引用和.操作符。"></a>用法一：代替解引用和.操作符。</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Entity entity;</span><br><span class="line">Entity* e = &amp;entity;</span><br><span class="line">(*e).<span class="built_in">print</span>();</span><br><span class="line">e-&gt;<span class="built_in">print</span>();   <span class="comment">//与前一行到达的意义效果均一样</span></span><br></pre></td></tr></tbody></table></figure><h2 id="用法二"><a href="#用法二" class="headerlink" title="用法二"></a>用法二</h2><p>重载操作符，在自定义的类中使用它。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span><span class="type">const</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">std::cout &lt;&lt; <span class="string">"hello!"</span> &lt;&lt; std::endl;</span><br><span class="line">}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ScopedPtr</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Entity* m_obj;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">ScopedPtr</span>(Entity* entity)</span><br><span class="line">:<span class="built_in">m_obj</span>(entity)</span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line">~<span class="built_in">ScopedPtr</span>()</span><br><span class="line">{</span><br><span class="line"><span class="keyword">delete</span> m_obj;     <span class="comment">//为什么，当Entity超出范围时，这个类会自动删除它</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">Entity* <span class="title">GetObject</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">return</span> m_obj;</span><br><span class="line">}</span><br><span class="line">Entity * <span class="keyword">operator</span> -&gt;()      <span class="comment">//重载运算符</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> m_obj;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">const</span> Entity* <span class="title">GetObject</span><span class="params">()</span><span class="type">const</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">return</span> m_obj;</span><br><span class="line">}</span><br><span class="line"><span class="type">const</span> Entity* <span class="keyword">operator</span> -&gt;()<span class="type">const</span>    <span class="comment">//const版本</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> m_obj;</span><br><span class="line">}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="type">const</span> ScopedPtr entity= <span class="keyword">new</span> <span class="built_in">Entity</span>(); </span><br><span class="line"><span class="comment">//调用const版本的函数</span></span><br><span class="line">entity.<span class="built_in">GetObject</span>()-&gt;<span class="built_in">print</span>();</span><br><span class="line">entity-&gt;<span class="built_in">print</span>();    <span class="comment">//使用了重载运算符，达到和上一行相同的意义和效果</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="用法三"><a href="#用法三" class="headerlink" title="用法三"></a>用法三</h2><p>实际使用箭头操作符，来获取内存中某个成员变量的偏移量。</p><p>处理字节流是会用到。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Vector3</span></span><br><span class="line">{</span><br><span class="line"><span class="type">float</span> x, y, x;</span><br><span class="line">};</span><br><span class="line"><span class="type">int</span> offset = (<span class="type">int</span>)&amp;((Vector3*)<span class="literal">nullptr</span>)-&gt;x;  <span class="comment">// 可以得到x在对象中的偏移量，y偏移量4，z偏移量是8；</span></span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/12/04/45-kao-bei-yu-kao-bei-gou-zao-han-shu-inc/"/>
      <url>/2023/12/04/45-kao-bei-yu-kao-bei-gou-zao-han-shu-inc/</url>
      
        <content type="html"><![CDATA[<h1 id="45-拷贝与拷贝构造函数-in-C"><a href="#45-拷贝与拷贝构造函数-in-C" class="headerlink" title="45 拷贝与拷贝构造函数 in C++"></a>45 拷贝与拷贝构造函数 in C++</h1><h2 id="深拷贝与浅拷贝"><a href="#深拷贝与浅拷贝" class="headerlink" title="深拷贝与浅拷贝"></a>深拷贝与浅拷贝</h2><h3 id="浅拷贝："><a href="#浅拷贝：" class="headerlink" title="浅拷贝："></a>浅拷贝：</h3><p>在复制指针时，新指针指向的地址与原来指针指向的地址是一样的，也就是同一个地址块。当更改一个时，访问另一个指针也会更改，因为两个指针共享所指向的内容。</p><p>这有时会出现内存泄露的问题。比如，当有一个类对象，其中包含指针类型的成员。另一个对象由该对象复制过来。对象的析构函数里有delete。对象超过作用域时，会自动调用析构函数释放两个对象。那么类中的指针所指向的地址就会被释放两次。当第一次释放结束后，该地址已经不属于我们了，因此程序会崩溃。</p><h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><p>在复制一个类对象时，借用拷贝构造函数，在拷贝构造函数中，先分配一段内存，再对内存进行复制操作。</p><p><strong>注意</strong></p><p><strong><em><code>always</code> 使用<code>const &amp;</code>传入函数参数。要不然每次传入参数都会有拷贝操作，拖慢程序速度</em>。</strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/12/04/44-zhi-neng-zhi-zhen-in-c/"/>
      <url>/2023/12/04/44-zhi-neng-zhi-zhen-in-c/</url>
      
        <content type="html"><![CDATA[<h1 id="44-智能指针-in-C"><a href="#44-智能指针-in-C" class="headerlink" title="44 智能指针 in C++"></a>44 智能指针 in C++</h1><h3 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h3><p>智能指针的行为类似于常规指针，区别在于他复杂内存的自动释放，当对象超过其作用域时。</p><p>某个时刻只能有一个<code>unique_ptr</code>指向一个给定的对象。当<code>unique_pyr</code>被销毁时，它所指向的对象的也会被销毁。</p><h3 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a><code>unique_ptr</code></h3><p>作用域指针，超过作用域时，就会调用delete。</p><p>该指针不能复制，只能是唯一的。因为如果复制的话，会有两个指针指向同一片区域，当其中有一个释放后，另一个指针会指向一块已经释放的区域，这显然是不行的。</p><p>基本没有什么开销。</p><p>使用<code>unique_pt</code>r时，<code>#include&lt;memory&gt;</code></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Entity</span>()</span><br><span class="line">{</span><br><span class="line">std::cout &lt;&lt; <span class="string">"Created Entity!"</span> &lt;&lt; std::endl;</span><br><span class="line">}</span><br><span class="line">~<span class="built_in">Entity</span>()</span><br><span class="line">{</span><br><span class="line">std::cout &lt;&lt; <span class="string">"Destroyed Entity!"</span> &lt;&lt; std::endl;</span><br><span class="line">}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">{</span><br><span class="line">std::unique_ptr&lt;Entity&gt;<span class="built_in">entity</span>(<span class="keyword">new</span> <span class="built_in">Entity</span>());</span><br><span class="line"><span class="comment">//std::unique_ptr&lt;Entity&gt;entity3 = new Entity();         //unique_ptr必须显式调用构造函数</span></span><br><span class="line"></span><br><span class="line">std::unique_ptr&lt;Entity&gt;entity2 = std::<span class="built_in">make_unique</span>&lt;Entity&gt;();  <span class="comment">//这种调用方式更安全</span></span><br><span class="line">}</span><br><span class="line"><span class="comment">//超过这个作用域时，指针就会被自动释放。</span></span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><h3 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h3></blockquote><p>允许多个<code>shared_ptr</code>指针指向同一个对象。同时会分配一个引用计数。每<code>copy</code>一个，引用计数就会<code>+1</code>。当引用计数<code>=0</code>时，对象被销毁。</p><p>会有一点开销，因为维护了一个引用计数。</p><h3 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h3><p>当该指针由<code>shared_ptr</code>赋值来的时候，<code>shared_ptr</code>的引用计数不会增加。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/12/04/43-dui-xiang-sheng-cun-qi-dui-xiang-zai-zhan-shang-de-sheng-cun-in-c/"/>
      <url>/2023/12/04/43-dui-xiang-sheng-cun-qi-dui-xiang-zai-zhan-shang-de-sheng-cun-in-c/</url>
      
        <content type="html"><![CDATA[<h1 id="43-对象生存期，对象在栈上的生存-in-C"><a href="#43-对象生存期，对象在栈上的生存-in-C" class="headerlink" title="43 对象生存期，对象在栈上的生存 in C++"></a>43 对象生存期，对象在栈上的生存 in C++</h1><p>在栈中创建的对象，一旦超过作用域，就会被自动销毁释放。</p><p>在局部函数中创建变量，并返回一个指向它的指针，是错误的。</p><p>这时，有两条路可以走，</p><p>第一个是在外部创建变量，传入函数体，然后在函数体内部去为他赋值之类的。</p><p>第二个是类作用域。类的析构函数是对象在超过作用域时自动调用的，可以在析构函数中，加入delete语句，在构造函数中，加入new语句。这样就可以让避免堆出现问题。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/12/04/42-this-guan-jian-zi-in-c/"/>
      <url>/2023/12/04/42-this-guan-jian-zi-in-c/</url>
      
        <content type="html"><![CDATA[<h1 id="42-this关键字-in-C"><a href="#42-this关键字-in-C" class="headerlink" title="42 this关键字 in C++"></a>42 this关键字 in C++</h1><p><code>this</code>是一个指向当前对象实例的指针。</p><p>在构造函数赋值时，最好使用<code>this</code>；尤其当函数列表参数与成员变量名字一样时，必须得使用了。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintEntity2</span><span class="params">(Entity2* e)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintEntity2</span><span class="params">(Entity2 &amp; e)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">class</span> Entity2</span>{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> x, y;</span><br><span class="line"><span class="built_in">Entity2</span>(<span class="type">int</span> x, <span class="type">int</span> y)</span><br><span class="line">{</span><br><span class="line"><span class="comment">// Entity2 * e = this;         //该类型的一个指针，指向当前对象</span></span><br><span class="line"><span class="keyword">this</span>-&gt;x = x;</span><br><span class="line"><span class="keyword">this</span>-&gt;y = y;</span><br><span class="line">(*<span class="keyword">this</span>).x = x;                <span class="comment">//对指针解引用后赋值，和上面的效果是一样的，通常还是按上面的那么写</span></span><br><span class="line">(*<span class="keyword">this</span>).y = y;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">PrintEntity2</span>(<span class="keyword">this</span>);         <span class="comment">//很好的诠释了this的意义，指向当前对象的指针</span></span><br><span class="line">        <span class="built_in">PrintEntity2</span>(*<span class="keyword">this</span>);        <span class="comment">//参数是引用，就传入解引用</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintEntity2</span><span class="params">(Entity2* e)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>xxxxxxxxxx&nbsp;struct Vector{    int X, Y;​    Vector(int x,int y)        :X(x),Y(y){}​    Vector Add(const Vector&amp; other)const    {        return Vector(X + other.X, Y + other.Y); &nbsp; &nbsp; &nbsp;//在return里直接调用构造函数，代码非常简练    }​    Vector operator + (const Vector&amp; other)const    {        return Add(other); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//可以直接调用Add()    } &nbsp; &nbsp; &nbsp; &nbsp;bool operator == (const Vector&amp; other) const    {        return X == other.X &amp;&amp; Y == other.Y; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //简练，要记得这么写​    }    bool operator != (const Vector&amp; other) const    {        //return !operator==(other); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  //也对，但是比较奇怪        return !(*this == other); &nbsp; &nbsp;//使用重载过的== 操作符​    }​    std::ostream &amp; operator &lt;&lt; (std::ostream&amp; stream,const Vector&amp;other) &nbsp;const &nbsp; &nbsp; //重载&lt;&lt;运算符,这里提示函数参数过多    {        stream &lt;&lt; other.X &lt;&lt; “ “ &lt;&lt; other.Y &lt;&lt; std::endl;        return stream;    }​};​Vector v1(2, 3);Vector v2(1, 2);Vector result=v1 + v2;​std::cout &lt;&lt; result &lt;&lt; std::endl;c++</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/12/04/41-yun-suan-fu-ji-qi-chong-zai-in-c/"/>
      <url>/2023/12/04/41-yun-suan-fu-ji-qi-chong-zai-in-c/</url>
      
        <content type="html"><![CDATA[<h1 id="41-运算符及其重载-in-C"><a href="#41-运算符及其重载-in-C" class="headerlink" title="41 运算符及其重载 in C++"></a>41 运算符及其重载 in C++</h1><p>运算符是一种我们使用的一种符号，通常代替一个函数来执行一些事情。运算符就是一种函数。</p><p>重载：给运算符赋予新的含义，或者添加参数，或者创建。</p><p>重载<code>+</code>里调用了<code>Add()</code>函数，一般项目里都写上。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Vector</span></span><br><span class="line">{</span><br><span class="line"><span class="type">int</span> X, Y;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Vector</span>(<span class="type">int</span> x,<span class="type">int</span> y)</span><br><span class="line">:<span class="built_in">X</span>(x),<span class="built_in">Y</span>(y){}</span><br><span class="line"></span><br><span class="line"><span class="function">Vector <span class="title">Add</span><span class="params">(<span class="type">const</span> Vector&amp; other)</span><span class="type">const</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Vector</span>(X + other.X, Y + other.Y);      <span class="comment">//在return里直接调用构造函数，代码非常简练</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">Vector <span class="keyword">operator</span> + (<span class="type">const</span> Vector&amp; other)<span class="type">const</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Add</span>(other);                        <span class="comment">//可以直接调用Add()</span></span><br><span class="line">}</span><br><span class="line">    </span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> == (<span class="type">const</span> Vector&amp; other) <span class="type">const</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> X == other.X &amp;&amp; Y == other.Y;               <span class="comment">//简练，要记得这么写</span></span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> != (<span class="type">const</span> Vector&amp; other) <span class="type">const</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">//return !operator==(other);            //也对，但是比较奇怪</span></span><br><span class="line"><span class="keyword">return</span> !(*<span class="keyword">this</span> == other);    <span class="comment">//使用重载过的== 操作符</span></span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">std::ostream &amp; <span class="keyword">operator</span> &lt;&lt; (std::ostream&amp; stream,<span class="type">const</span> Vector&amp;other)  <span class="type">const</span>     <span class="comment">//重载&lt;&lt;运算符,这里提示函数参数过多</span></span><br><span class="line">{</span><br><span class="line">stream &lt;&lt; other.X &lt;&lt; <span class="string">" "</span> &lt;&lt; other.Y &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span> stream;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function">Vector <span class="title">v1</span><span class="params">(<span class="number">2</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line"><span class="function">Vector <span class="title">v2</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">Vector result=v1 + v2;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; result &lt;&lt; std::endl;</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/12/04/40-yin-shi-zhuan-huan-yu-explicit-guan-jian-zi/"/>
      <url>/2023/12/04/40-yin-shi-zhuan-huan-yu-explicit-guan-jian-zi/</url>
      
        <content type="html"><![CDATA[<h1 id="40-隐式转换与explicit关键字"><a href="#40-隐式转换与explicit关键字" class="headerlink" title="40 隐式转换与explicit关键字"></a>40 隐式转换与explicit关键字</h1><h2 id="Entity类"><a href="#Entity类" class="headerlink" title="Entity类"></a>Entity类</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">String m_Name;</span><br><span class="line"><span class="type">int</span> m_Age;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Entity</span>()</span><br><span class="line">:<span class="built_in">m_Name</span>(<span class="string">"Unknown"</span>),<span class="built_in">m_Age</span>(<span class="number">-1</span>){}</span><br><span class="line"></span><br><span class="line"><span class="built_in">Entity</span>(<span class="type">const</span> String&amp; name)</span><br><span class="line">:<span class="built_in">m_Name</span>(name),<span class="built_in">m_Age</span>(<span class="number">-1</span>){}</span><br><span class="line"></span><br><span class="line"><span class="built_in">Entity</span>(<span class="type">int</span> age)</span><br><span class="line">:<span class="built_in">m_Name</span>(<span class="string">"Unknown"</span>),<span class="built_in">m_Age</span>(age){}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">const</span> String&amp; <span class="title">GetName</span><span class="params">()</span><span class="type">const</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">return</span> m_Name;</span><br><span class="line">}</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h2 id="正常创建对象及实例化"><a href="#正常创建对象及实例化" class="headerlink" title="正常创建对象及实例化"></a>正常创建对象及实例化</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Entity <span class="title">a</span><span class="params">(<span class="string">"arya"</span>)</span></span>;      <span class="comment">// 调用第二个构造函数</span></span><br><span class="line"><span class="function">Entity <span class="title">b</span><span class="params">(<span class="number">22</span>)</span></span>;          <span class="comment">//调用第三个构造函数</span></span><br></pre></td></tr></tbody></table></figure><h2 id="涉及隐式转换的创建对象及实例化"><a href="#涉及隐式转换的创建对象及实例化" class="headerlink" title="涉及隐式转换的创建对象及实例化"></a>涉及隐式转换的创建对象及实例化</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Entity b = <span class="number">22</span>;</span><br></pre></td></tr></tbody></table></figure><p>隐式构造函数：将22转换成一个<code>Entity</code>，因为<code>Entity</code>类中有一个接受<code>int</code>类型参数的构造函数。</p><p>xxxxxxxxxx&nbsp;struct Vector{    int X, Y;​    Vector(int x,int y)        :X(x),Y(y){}​    Vector Add(const Vector&amp; other)const    {        return Vector(X + other.X, Y + other.Y); &nbsp; &nbsp; &nbsp;//在return里直接调用构造函数，代码非常简练    }​    Vector operator + (const Vector&amp; other)const    {        return Add(other); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//可以直接调用Add()    } &nbsp; &nbsp; &nbsp; &nbsp;bool operator == (const Vector&amp; other) const    {        return X == other.X &amp;&amp; Y == other.Y; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //简练，要记得这么写​    }    bool operator != (const Vector&amp; other) const    {        //return !operator==(other); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  //也对，但是比较奇怪        return !(*this == other); &nbsp; &nbsp;//使用重载过的== 操作符​    }​    std::ostream &amp; operator &lt;&lt; (std::ostream&amp; stream,const Vector&amp;other) &nbsp;const &nbsp; &nbsp; //重载&lt;&lt;运算符,这里提示函数参数过多    {        stream &lt;&lt; other.X &lt;&lt; “ “ &lt;&lt; other.Y &lt;&lt; std::endl;        return stream;    }​};​Vector v1(2, 3);Vector v2(1, 2);Vector result=v1 + v2;​std::cout &lt;&lt; result &lt;&lt; std::endl;c++</p><p>例如，<code>const char*</code>到 <code>string</code> 到 <code>Entity</code></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Entity a = <span class="string">"arya"</span>;     <span class="comment">//❌，因为“arya”是const char * 类型，到达Entity中间还有一步。</span></span><br><span class="line">Entity a = std::<span class="built_in">string</span>(<span class="string">"arya"</span>);     <span class="comment">//✔ ，string默认构造函数，将字符串显示转换为string类型，c++隐式的转换为Entity</span></span><br><span class="line">Entity a = <span class="built_in">Entity</span>(<span class="string">"arya"</span>);      <span class="comment">//✔，将const char *隐式转换为string,然后调用构造函数</span></span><br></pre></td></tr></tbody></table></figure><h2 id="explicit关键字：禁止隐式调用构造函数"><a href="#explicit关键字：禁止隐式调用构造函数" class="headerlink" title="explicit关键字：禁止隐式调用构造函数"></a>explicit关键字：禁止隐式调用构造函数</h2><p>C++编译器默认支持隐式转换的。有时需要禁止隐式转换，这就是<code>explicit</code>存在的意义。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">Entity</span><span class="params">(<span class="type">int</span> age)</span></span></span><br><span class="line"><span class="function">:m_Name(<span class="string">"Unknown"</span>),m_Age(age){</span>}</span><br><span class="line"></span><br><span class="line">Entity b = <span class="number">22</span>;         <span class="comment">//会报错，不能从int转换为Entity</span></span><br></pre></td></tr></tbody></table></figure><h3 id="总结：除非必要，可以不用隐式转换，就正常的创建对象及实例化。"><a href="#总结：除非必要，可以不用隐式转换，就正常的创建对象及实例化。" class="headerlink" title="总结：除非必要，可以不用隐式转换，就正常的创建对象及实例化。"></a>总结：除非必要，可以不用隐式转换，就正常的创建对象及实例化。</h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/12/04/39-new-guan-jian-zi-in-c/"/>
      <url>/2023/12/04/39-new-guan-jian-zi-in-c/</url>
      
        <content type="html"><![CDATA[<h1 id="39-new关键字-in-C"><a href="#39-new关键字-in-C" class="headerlink" title="39 new关键字 in C++"></a>39 new关键字 in C++</h1><h3 id="在编写c-程序语言时，应该关心内存、性能和优化问题。如果不在乎这些的话，真的不必使用这个语言，其他的语言会更简单方便。"><a href="#在编写c-程序语言时，应该关心内存、性能和优化问题。如果不在乎这些的话，真的不必使用这个语言，其他的语言会更简单方便。" class="headerlink" title="在编写c++程序语言时，应该关心内存、性能和优化问题。如果不在乎这些的话，真的不必使用这个语言，其他的语言会更简单方便。"></a>在编写c++程序语言时，应该关心内存、性能和优化问题。如果不在乎这些的话，真的不必使用这个语言，其他的语言会更简单方便。</h3><h2 id="new的主要目的是在堆上分配内存"><a href="#new的主要目的是在堆上分配内存" class="headerlink" title="new的主要目的是在堆上分配内存"></a>new的主要目的是在堆上分配内存</h2><h3 id="new-数据类型"><a href="#new-数据类型" class="headerlink" title="new  数据类型"></a><u><strong>new  数据类型</strong></u></h3><h4 id="无论是基本数据类型，还是类类型，还是数据）类型决定了在内存中会分配多大的空间。"><a href="#无论是基本数据类型，还是类类型，还是数据）类型决定了在内存中会分配多大的空间。" class="headerlink" title="无论是基本数据类型，还是类类型，还是数据）类型决定了在内存中会分配多大的空间。"></a>无论是基本数据类型，还是类类型，还是数据）类型决定了在内存中会分配多大的空间。</h4><h4 id="例如，new-int-向操作系统请求，给我一个4字节的连续的内存块，找到内存块后，返回一个指向这个内存的指针。这也可以看出，new比较消耗时间）"><a href="#例如，new-int-向操作系统请求，给我一个4字节的连续的内存块，找到内存块后，返回一个指向这个内存的指针。这也可以看出，new比较消耗时间）" class="headerlink" title="例如，new int ,向操作系统请求，给我一个4字节的连续的内存块，找到内存块后，返回一个指向这个内存的指针。这也可以看出，new比较消耗时间）"></a>例如，new int ,向操作系统请求，给我一个4字节的连续的内存块，找到内存块后，返回一个指向这个内存的指针。这也可以看出，new比较消耗时间）</h4><h2 id="new其实一种操作符，delete也是-要记得手动释放new分配的空间。"><a href="#new其实一种操作符，delete也是-要记得手动释放new分配的空间。" class="headerlink" title="new其实一种操作符，delete也是,要记得手动释放new分配的空间。"></a><u>new其实一种操作符，delete也是,要记得手动释放new分配的空间。</u></h2><h3 id="Entity类"><a href="#Entity类" class="headerlink" title="Entity类"></a>Entity类</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">String m_Name;</span><br><span class="line"><span class="type">int</span> m_Age;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Entity</span>()</span><br><span class="line">:<span class="built_in">m_Name</span>(<span class="string">"Unknown"</span>),<span class="built_in">m_Age</span>(<span class="number">-1</span>){}</span><br><span class="line"></span><br><span class="line"><span class="built_in">Entity</span>(<span class="type">const</span> String&amp; name)</span><br><span class="line">:<span class="built_in">m_Name</span>(name),<span class="built_in">m_Age</span>(<span class="number">-1</span>){}</span><br><span class="line"></span><br><span class="line"> <span class="built_in">Entity</span>(<span class="type">int</span> age)</span><br><span class="line">:<span class="built_in">m_Name</span>(<span class="string">"Unknown"</span>),<span class="built_in">m_Age</span>(age){}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">const</span> String&amp; <span class="title">GetName</span><span class="params">()</span><span class="type">const</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">return</span> m_Name;</span><br><span class="line">}</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="new-和delete操作符的使用"><a href="#new-和delete操作符的使用" class="headerlink" title="new 和delete操作符的使用"></a>new 和delete操作符的使用</h3><p>new在分配内存的同时，还可以调用构造函数。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">2</span>;   <span class="comment">//在栈上分配</span></span><br><span class="line"><span class="type">int</span>* b = <span class="keyword">new</span> <span class="type">int</span>;    <span class="comment">//在堆上分配4字节</span></span><br><span class="line"><span class="type">int</span>* c = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">2</span>];    <span class="comment">//在堆上分配数据，占内存4x2=8字节</span></span><br><span class="line"></span><br><span class="line">Entity* entity = <span class="keyword">new</span> Entity[<span class="number">5</span>]; <span class="comment">//分配数据</span></span><br><span class="line"></span><br><span class="line">Entity* entity2 = <span class="keyword">new</span> <span class="built_in">Entity</span>();    <span class="comment">//new不仅分配内存，还调用了构造函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> entity2;</span><br><span class="line"><span class="keyword">delete</span>[] entity;     <span class="comment">//释放数组</span></span><br><span class="line"><span class="keyword">delete</span>[] c;</span><br><span class="line"><span class="keyword">delete</span> b;</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/12/04/11-how-to-debug-c-vs/"/>
      <url>/2023/12/04/11-how-to-debug-c-vs/</url>
      
        <content type="html"><![CDATA[<h2 id="11-How-to-DEBUG-C-VS"><a href="#11-How-to-DEBUG-C-VS" class="headerlink" title="11 How to DEBUG C++ VS"></a>11 How to DEBUG C++ VS</h2><h3 id="Breakpoint"><a href="#Breakpoint" class="headerlink" title="Breakpoint"></a>Breakpoint</h3><p>设置断点</p><h1 id="Read-memory"><a href="#Read-memory" class="headerlink" title="Read memory"></a>Read memory</h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/12/02/hello-world/"/>
      <url>/2023/12/02/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><p>可以写东西嘛</p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>

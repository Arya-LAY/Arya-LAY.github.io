<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Git学习</title>
      <link href="/2023/12/05/git-xue-xi/"/>
      <url>/2023/12/05/git-xue-xi/</url>
      
        <content type="html"><![CDATA[<h2 id="Git介绍"><a href="#Git介绍" class="headerlink" title="Git介绍"></a>Git介绍</h2><p>Git是一种非常流行的分布式版本控制系统。版本控制系统，摆脱手动管理文件各个版本的麻烦。分布式的设计更安全，因为不再依赖中心服务器，不能联网的时候也能修改。</p><h2 id="Git安装"><a href="#Git安装" class="headerlink" title="Git安装"></a>Git安装</h2><p>在Windows平台下，在官网下载，默认选项安装。</p><p>在安装后，右键可以打开Git Bash使用。</p><p>在命令行输入：用自己<code>GitHub</code>的账户和相应绑定的邮箱。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">"xxx"</span></span><br><span class="line">git config --global user.email <span class="string">"xxx"</span></span><br></pre></td></tr></tbody></table></figure><h2 id="Git使用"><a href="#Git使用" class="headerlink" title="Git使用"></a>Git使用</h2><h4 id="增加提交文件"><a href="#增加提交文件" class="headerlink" title="增加提交文件"></a>增加提交文件</h4><p>可以把版本库理解成一个仓库，里面放着我们的文件，同时git帮助我们追踪记录文件各个版本的信息。</p><p>新建一个空文件，注意路径不要有中文。</p><h5 id="进入该文件，把它变成Git可以管理的仓库："><a href="#进入该文件，把它变成Git可以管理的仓库：" class="headerlink" title="进入该文件，把它变成Git可以管理的仓库："></a>进入该文件，把它变成Git可以管理的仓库：</h5><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></tbody></table></figure><p><img src="D:\MyBlog\Hexo\source\picture\git20231205152153.png"></p><h5 id="新建一个readme-txt文件，并添加到Git仓库"><a href="#新建一个readme-txt文件，并添加到Git仓库" class="headerlink" title="新建一个readme.txt文件，并添加到Git仓库"></a>新建一个<code>readme.txt</code>文件，并添加到Git仓库</h5><p>要先在该目录中新建文件，再add。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add readme.txt</span><br></pre></td></tr></tbody></table></figure><h5 id="提交到仓库"><a href="#提交到仓库" class="headerlink" title="提交到仓库"></a>提交到仓库</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m "write a read file"</span><br></pre></td></tr></tbody></table></figure><p><code>git commit</code>命令是将文件提交到仓库，<code>- m "xxx"</code>是对这次提交的说明，可以描述这次提交做了什么等。</p><p>这次说明提交了一个文件，有一行被添加了。</p><p><img src="D:\MyBlog\Hexo\source\picture\git20231205154712.png"></p><h5 id="修改文件"><a href="#修改文件" class="headerlink" title="修改文件"></a>修改文件</h5><p>在<code>readme.tx</code>t中添加一行。</p><p>然后看一下仓库状态：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></tbody></table></figure><p><img src="D:\MyBlog\Hexo\source\picture\git20231205155317.png"></p><p>这说明，对文件做了修改，但是还没有提交。</p><h5 id="查看修改："><a href="#查看修改：" class="headerlink" title="查看修改："></a>查看修改：</h5><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff readme.txt</span><br></pre></td></tr></tbody></table></figure><p><img src="D:\MyBlog\Hexo\source\picture\git20231205162540.png"></p><p>可以看到绿色那行，显示 增加了 <code>Git  is amazing.</code></p><p>这时候可以将文件添加，提交。在这个过程中，还可以看看仓库状态。</p><p><img src="D:\MyBlog\Hexo\source\picture\git20231205162954.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>The Best C++ 01</title>
      <link href="/2023/12/04/the-best-c/"/>
      <url>/2023/12/04/the-best-c/</url>
      
        <content type="html"><![CDATA[<h1 id="关于C"><a href="#关于C" class="headerlink" title="关于C++"></a>关于C++</h1>]]></content>
      
      
      <categories>
          
          <category> The Best C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/12/04/48-stdvector-shi-yong-you-hua/"/>
      <url>/2023/12/04/48-stdvector-shi-yong-you-hua/</url>
      
        <content type="html"><![CDATA[<h1 id="48-std-vector使用优化"><a href="#48-std-vector使用优化" class="headerlink" title="48 std::vector使用优化"></a>48 std::vector使用优化</h1><p>优化时，应该首先知道当你执行一个操作时，到底是怎么发生的，每一步是怎样工作的。</p><h3 id="push-back-函数"><a href="#push-back-函数" class="headerlink" title="push_back()函数"></a><code>push_back()</code>函数</h3><p>当向容器中增加元素时，如果原来分配的内存不够大，就会重新分配另一块更大的新的内存。将原来的旧元素复制过来。这是拖慢速度的主要因素之一。</p><p>优化的思路之一，尽量避免复制操作。尤其是使用Vector时。</p><p>调用构造函数的次数</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Vertex</span></span><br><span class="line">{</span><br><span class="line"><span class="type">int</span> x, y, z;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Vertex</span>(<span class="type">float</span> X, <span class="type">float</span> Y, <span class="type">float</span> Z)</span><br><span class="line">:<span class="built_in">x</span>(X), <span class="built_in">y</span>(Y), <span class="built_in">z</span>(Z)</span><br><span class="line">{}</span><br><span class="line"></span><br><span class="line"><span class="built_in">Vertex</span>(<span class="type">const</span> Vertex&amp; vertices)                             <span class="comment">//拷贝构造函数</span></span><br><span class="line">:<span class="built_in">x</span>(vertices.x), <span class="built_in">y</span>(vertices.y), <span class="built_in">z</span>(vertices.z)</span><br><span class="line">{</span><br><span class="line">std::cout &lt;&lt; <span class="string">"Copied!"</span> &lt;&lt; std::endl;</span><br><span class="line">}</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>一共调用了6次构造函数。</p><p>第一次：在<code>main</code>中构造一个<code>Vertex(1,2,3</code>); 然后复制到了<code>Vertices</code>中。</p><p><strong>这里是优化的第一种方法：直接在Vector那个内存中构建元素。</strong></p><p>第2、3次：创建<code>Vertex(4,5,6)</code>，复制进<code>Vector</code>中复制一次。调整<code>vector</code>的大小，将元素1又复制了一次。</p><p>第4、5、6次：创建<code>Vertex(7,8,9)</code>，复制进Vector中复制一次。调整<code>vector</code>的大小，将元素1，2又复制了一次。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;Vertex&gt;vertices;</span><br><span class="line"></span><br><span class="line">vertices.<span class="built_in">push_back</span>(<span class="built_in">Vertex</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> ));    </span><br><span class="line">vertices.<span class="built_in">push_back</span>(<span class="built_in">Vertex</span>(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>));</span><br><span class="line">vertices.<span class="built_in">push_back</span>(<span class="built_in">Vertex</span>(<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>));</span><br></pre></td></tr></tbody></table></figure><p><strong>第二种优化策略：如果提前知道Vector大小，就可以避免后续的大小调整，而带来的复制。</strong></p><p>reserve()函数设置容器大小。下面的代码目前仅有3次复制构造函数的调用。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;Vertex&gt;vertices;</span><br><span class="line">vertices.<span class="built_in">reserve</span>(<span class="number">3</span>);              <span class="comment">//预先设置大小</span></span><br><span class="line">vertices.<span class="built_in">push_back</span>(<span class="built_in">Vertex</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> ));    </span><br><span class="line">vertices.<span class="built_in">push_back</span>(<span class="built_in">Vertex</span>(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>));</span><br><span class="line">vertices.<span class="built_in">push_back</span>(<span class="built_in">Vertex</span>(<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>));</span><br></pre></td></tr></tbody></table></figure><p><strong>使用第一种优化策略</strong></p><p>直接在<code>Vector</code>的内存中创建对象。</p><p><code>emplace_back()</code></p><p>这是使用参数列表创建对象，代表告诉编译器，在<code>Vector</code>的内存中，用以下参数直接创建对象。此时，已经不会再调用拷贝构造函数了。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;Vertex&gt;vertices;</span><br><span class="line">vertices.<span class="built_in">reserve</span>(<span class="number">3</span>);</span><br><span class="line">vertices.<span class="built_in">emplace_back</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> );    </span><br><span class="line">vertices.<span class="built_in">emplace_back</span>(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line">vertices.<span class="built_in">emplace_back</span>(<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>);</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/12/04/47-dong-tai-shu-zu-vector-in-c/"/>
      <url>/2023/12/04/47-dong-tai-shu-zu-vector-in-c/</url>
      
        <content type="html"><![CDATA[<h1 id="47-动态数组vector-in-C"><a href="#47-动态数组vector-in-C" class="headerlink" title="47 动态数组vector in C++"></a>47 动态数组vector in C++</h1><h3 id="标准模板库STL，包含很多容器，模板化，可以自己觉得容器中的数据类型"><a href="#标准模板库STL，包含很多容器，模板化，可以自己觉得容器中的数据类型" class="headerlink" title="标准模板库STL，包含很多容器，模板化，可以自己觉得容器中的数据类型"></a>标准模板库<code>STL</code>，包含很多容器，模板化，可以自己觉得容器中的数据类型</h3><h2 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h2><p>在std命名空间中</p><p>动态数组，数组大小是可变的。创建时可以不指定大小。</p><p>实际上以向量<code>vector</code>命名是不太合适的，<code>ArrayList</code>更合理一些。</p><p>速度不是标准模板库优先考虑的东西，因此许多团队会写自己的模板库，比如<code>EASTL</code>，这个是开源的。</p><h3 id="Vector-工作方式"><a href="#Vector-工作方式" class="headerlink" title="Vector 工作方式"></a>Vector 工作方式</h3><p>添加数据时，会改变大小。每当向数组中添加数据时，会在内存中新开辟一块比原来大的区域，把原来的Vector复制过来，填上新数据，再删除旧的Vector。</p><h3 id="Vector最好存储的是对象"><a href="#Vector最好存储的是对象" class="headerlink" title="Vector最好存储的是对象"></a>Vector最好存储的是对象</h3><p>在创建<code>Vector</code>, 指定数据类型时，可以指定类类型，也可以指定类指针类型。</p><p>指定类类型，存储的是对象。这种存储方式优于类指针。因为当存储对象是，Vector中的数据是在条线上的，各个对象是挨着的。当遍历，赋值时速度更快。存储类指针时，放到一起的是指针，数据可能在内存中的各个地方。另一方面，当增加新数据时，第一种方式要复制所有的数据，第二中方式只需复制指针。</p><p>但无论如何，指针形式都不是优先考虑的。只有在必须使用是才使用。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Vertex</span></span><br><span class="line">{</span><br><span class="line"><span class="type">int</span> x, y, z;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">std::ostream&amp; <span class="keyword">operator</span> &lt;&lt; (std::ostream&amp; stream,<span class="type">const</span> Vertex&amp; vertices)   <span class="comment">//重载 &lt;&lt;</span></span><br><span class="line">{</span><br><span class="line">stream &lt;&lt; vertices.x &lt;&lt;<span class="string">","</span>&lt;&lt; vertices.y &lt;&lt;<span class="string">","</span>&lt;&lt; vertices.z;</span><br><span class="line"><span class="keyword">return</span> stream;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="添加遍历数据"><a href="#添加遍历数据" class="headerlink" title="添加遍历数据"></a>添加遍历数据</h3><p>添加元素函数：<code>push.back()</code></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;Vertex&gt;vertices;</span><br><span class="line"></span><br><span class="line">vertices.<span class="built_in">push_back</span>({ <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> });    <span class="comment">//初始化列表</span></span><br><span class="line">vertices.<span class="built_in">push_back</span>({ <span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span> });</span><br></pre></td></tr></tbody></table></figure><p>遍历函数</p><p>第一种遍历用了重载过的<code>&lt;&lt;</code>符号，一般可以自己写一个<code>print()</code>函数。</p><p>第二种遍历是范围<code>for</code>语句<code>，c++11</code>中新的方法。为了避免复制，应该使用引用&amp;。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; vertices.<span class="built_in">size</span>(); i++)</span><br><span class="line">    std::cout &lt;&lt; vertices[i] &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">const</span> Vertex&amp; v:vertices)</span><br><span class="line">    std::cout &lt;&lt; v&lt;&lt; std::endl;</span><br></pre></td></tr></tbody></table></figure><h3 id="删除某个元素"><a href="#删除某个元素" class="headerlink" title="删除某个元素"></a>删除某个元素</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除第2个元素,不能直接写2</span></span><br><span class="line">vertices.<span class="built_in">erase</span>(vertices.<span class="built_in">begin</span>() + <span class="number">1</span>);</span><br></pre></td></tr></tbody></table></figure><h3 id="清空整个数组"><a href="#清空整个数组" class="headerlink" title="清空整个数组"></a>清空整个数组</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vertices.<span class="built_in">clear</span>()</span><br></pre></td></tr></tbody></table></figure><h3 id="当容器作为函数参数传入时，一定要引用传入"><a href="#当容器作为函数参数传入时，一定要引用传入" class="headerlink" title="当容器作为函数参数传入时，一定要引用传入"></a>当容器作为函数参数传入时，一定要引用传入</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Function</span><span class="params">(<span class="type">const</span> std::vector&lt;Vertex&gt;&amp; vertices)</span>     <span class="comment">//引用传入参数</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">std::vector&lt;Vertex&gt;vertices;</span><br><span class="line"></span><br><span class="line">vertices.<span class="built_in">push_back</span>({ <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> });    <span class="comment">//初始化列表</span></span><br><span class="line">vertices.<span class="built_in">push_back</span>({ <span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span> });</span><br><span class="line"></span><br><span class="line"><span class="built_in">Function</span>(vertices);</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/12/04/46-jian-tou-cao-zuo-fu-in-c/"/>
      <url>/2023/12/04/46-jian-tou-cao-zuo-fu-in-c/</url>
      
        <content type="html"><![CDATA[<h1 id="46-箭头操作符-in-C"><a href="#46-箭头操作符-in-C" class="headerlink" title="46 箭头操作符 in C++"></a>46 箭头操作符 in C++</h1><h2 id="用法一：代替解引用和-操作符。"><a href="#用法一：代替解引用和-操作符。" class="headerlink" title="用法一：代替解引用和.操作符。"></a>用法一：代替解引用和.操作符。</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Entity entity;</span><br><span class="line">Entity* e = &amp;entity;</span><br><span class="line">(*e).<span class="built_in">print</span>();</span><br><span class="line">e-&gt;<span class="built_in">print</span>();   <span class="comment">//与前一行到达的意义效果均一样</span></span><br></pre></td></tr></tbody></table></figure><h2 id="用法二"><a href="#用法二" class="headerlink" title="用法二"></a>用法二</h2><p>重载操作符，在自定义的类中使用它。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span><span class="type">const</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">std::cout &lt;&lt; <span class="string">"hello!"</span> &lt;&lt; std::endl;</span><br><span class="line">}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ScopedPtr</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Entity* m_obj;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">ScopedPtr</span>(Entity* entity)</span><br><span class="line">:<span class="built_in">m_obj</span>(entity)</span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line">~<span class="built_in">ScopedPtr</span>()</span><br><span class="line">{</span><br><span class="line"><span class="keyword">delete</span> m_obj;     <span class="comment">//为什么，当Entity超出范围时，这个类会自动删除它</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">Entity* <span class="title">GetObject</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">return</span> m_obj;</span><br><span class="line">}</span><br><span class="line">Entity * <span class="keyword">operator</span> -&gt;()      <span class="comment">//重载运算符</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> m_obj;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">const</span> Entity* <span class="title">GetObject</span><span class="params">()</span><span class="type">const</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">return</span> m_obj;</span><br><span class="line">}</span><br><span class="line"><span class="type">const</span> Entity* <span class="keyword">operator</span> -&gt;()<span class="type">const</span>    <span class="comment">//const版本</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> m_obj;</span><br><span class="line">}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="type">const</span> ScopedPtr entity= <span class="keyword">new</span> <span class="built_in">Entity</span>(); </span><br><span class="line"><span class="comment">//调用const版本的函数</span></span><br><span class="line">entity.<span class="built_in">GetObject</span>()-&gt;<span class="built_in">print</span>();</span><br><span class="line">entity-&gt;<span class="built_in">print</span>();    <span class="comment">//使用了重载运算符，达到和上一行相同的意义和效果</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="用法三"><a href="#用法三" class="headerlink" title="用法三"></a>用法三</h2><p>实际使用箭头操作符，来获取内存中某个成员变量的偏移量。</p><p>处理字节流是会用到。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Vector3</span></span><br><span class="line">{</span><br><span class="line"><span class="type">float</span> x, y, x;</span><br><span class="line">};</span><br><span class="line"><span class="type">int</span> offset = (<span class="type">int</span>)&amp;((Vector3*)<span class="literal">nullptr</span>)-&gt;x;  <span class="comment">// 可以得到x在对象中的偏移量，y偏移量4，z偏移量是8；</span></span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/12/04/45-kao-bei-yu-kao-bei-gou-zao-han-shu-inc/"/>
      <url>/2023/12/04/45-kao-bei-yu-kao-bei-gou-zao-han-shu-inc/</url>
      
        <content type="html"><![CDATA[<h1 id="45-拷贝与拷贝构造函数-in-C"><a href="#45-拷贝与拷贝构造函数-in-C" class="headerlink" title="45 拷贝与拷贝构造函数 in C++"></a>45 拷贝与拷贝构造函数 in C++</h1><h2 id="深拷贝与浅拷贝"><a href="#深拷贝与浅拷贝" class="headerlink" title="深拷贝与浅拷贝"></a>深拷贝与浅拷贝</h2><h3 id="浅拷贝："><a href="#浅拷贝：" class="headerlink" title="浅拷贝："></a>浅拷贝：</h3><p>在复制指针时，新指针指向的地址与原来指针指向的地址是一样的，也就是同一个地址块。当更改一个时，访问另一个指针也会更改，因为两个指针共享所指向的内容。</p><p>这有时会出现内存泄露的问题。比如，当有一个类对象，其中包含指针类型的成员。另一个对象由该对象复制过来。对象的析构函数里有delete。对象超过作用域时，会自动调用析构函数释放两个对象。那么类中的指针所指向的地址就会被释放两次。当第一次释放结束后，该地址已经不属于我们了，因此程序会崩溃。</p><h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><p>在复制一个类对象时，借用拷贝构造函数，在拷贝构造函数中，先分配一段内存，再对内存进行复制操作。</p><p><strong>注意</strong></p><p><strong><em><code>always</code> 使用<code>const &amp;</code>传入函数参数。要不然每次传入参数都会有拷贝操作，拖慢程序速度</em>。</strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/12/04/44-zhi-neng-zhi-zhen-in-c/"/>
      <url>/2023/12/04/44-zhi-neng-zhi-zhen-in-c/</url>
      
        <content type="html"><![CDATA[<h1 id="44-智能指针-in-C"><a href="#44-智能指针-in-C" class="headerlink" title="44 智能指针 in C++"></a>44 智能指针 in C++</h1><h3 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h3><p>智能指针的行为类似于常规指针，区别在于他复杂内存的自动释放，当对象超过其作用域时。</p><p>某个时刻只能有一个<code>unique_ptr</code>指向一个给定的对象。当<code>unique_pyr</code>被销毁时，它所指向的对象的也会被销毁。</p><h3 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a><code>unique_ptr</code></h3><p>作用域指针，超过作用域时，就会调用delete。</p><p>该指针不能复制，只能是唯一的。因为如果复制的话，会有两个指针指向同一片区域，当其中有一个释放后，另一个指针会指向一块已经释放的区域，这显然是不行的。</p><p>基本没有什么开销。</p><p>使用<code>unique_pt</code>r时，<code>#include&lt;memory&gt;</code></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Entity</span>()</span><br><span class="line">{</span><br><span class="line">std::cout &lt;&lt; <span class="string">"Created Entity!"</span> &lt;&lt; std::endl;</span><br><span class="line">}</span><br><span class="line">~<span class="built_in">Entity</span>()</span><br><span class="line">{</span><br><span class="line">std::cout &lt;&lt; <span class="string">"Destroyed Entity!"</span> &lt;&lt; std::endl;</span><br><span class="line">}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">{</span><br><span class="line">std::unique_ptr&lt;Entity&gt;<span class="built_in">entity</span>(<span class="keyword">new</span> <span class="built_in">Entity</span>());</span><br><span class="line"><span class="comment">//std::unique_ptr&lt;Entity&gt;entity3 = new Entity();         //unique_ptr必须显式调用构造函数</span></span><br><span class="line"></span><br><span class="line">std::unique_ptr&lt;Entity&gt;entity2 = std::<span class="built_in">make_unique</span>&lt;Entity&gt;();  <span class="comment">//这种调用方式更安全</span></span><br><span class="line">}</span><br><span class="line"><span class="comment">//超过这个作用域时，指针就会被自动释放。</span></span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><h3 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h3></blockquote><p>允许多个<code>shared_ptr</code>指针指向同一个对象。同时会分配一个引用计数。每<code>copy</code>一个，引用计数就会<code>+1</code>。当引用计数<code>=0</code>时，对象被销毁。</p><p>会有一点开销，因为维护了一个引用计数。</p><h3 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h3><p>当该指针由<code>shared_ptr</code>赋值来的时候，<code>shared_ptr</code>的引用计数不会增加。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/12/04/43-dui-xiang-sheng-cun-qi-dui-xiang-zai-zhan-shang-de-sheng-cun-in-c/"/>
      <url>/2023/12/04/43-dui-xiang-sheng-cun-qi-dui-xiang-zai-zhan-shang-de-sheng-cun-in-c/</url>
      
        <content type="html"><![CDATA[<h1 id="43-对象生存期，对象在栈上的生存-in-C"><a href="#43-对象生存期，对象在栈上的生存-in-C" class="headerlink" title="43 对象生存期，对象在栈上的生存 in C++"></a>43 对象生存期，对象在栈上的生存 in C++</h1><p>在栈中创建的对象，一旦超过作用域，就会被自动销毁释放。</p><p>在局部函数中创建变量，并返回一个指向它的指针，是错误的。</p><p>这时，有两条路可以走，</p><p>第一个是在外部创建变量，传入函数体，然后在函数体内部去为他赋值之类的。</p><p>第二个是类作用域。类的析构函数是对象在超过作用域时自动调用的，可以在析构函数中，加入delete语句，在构造函数中，加入new语句。这样就可以让避免堆出现问题。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/12/04/42-this-guan-jian-zi-in-c/"/>
      <url>/2023/12/04/42-this-guan-jian-zi-in-c/</url>
      
        <content type="html"><![CDATA[<h1 id="42-this关键字-in-C"><a href="#42-this关键字-in-C" class="headerlink" title="42 this关键字 in C++"></a>42 this关键字 in C++</h1><p><code>this</code>是一个指向当前对象实例的指针。</p><p>在构造函数赋值时，最好使用<code>this</code>；尤其当函数列表参数与成员变量名字一样时，必须得使用了。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintEntity2</span><span class="params">(Entity2* e)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintEntity2</span><span class="params">(Entity2 &amp; e)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">class</span> Entity2</span>{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> x, y;</span><br><span class="line"><span class="built_in">Entity2</span>(<span class="type">int</span> x, <span class="type">int</span> y)</span><br><span class="line">{</span><br><span class="line"><span class="comment">// Entity2 * e = this;         //该类型的一个指针，指向当前对象</span></span><br><span class="line"><span class="keyword">this</span>-&gt;x = x;</span><br><span class="line"><span class="keyword">this</span>-&gt;y = y;</span><br><span class="line">(*<span class="keyword">this</span>).x = x;                <span class="comment">//对指针解引用后赋值，和上面的效果是一样的，通常还是按上面的那么写</span></span><br><span class="line">(*<span class="keyword">this</span>).y = y;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">PrintEntity2</span>(<span class="keyword">this</span>);         <span class="comment">//很好的诠释了this的意义，指向当前对象的指针</span></span><br><span class="line">        <span class="built_in">PrintEntity2</span>(*<span class="keyword">this</span>);        <span class="comment">//参数是引用，就传入解引用</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintEntity2</span><span class="params">(Entity2* e)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>xxxxxxxxxx&nbsp;struct Vector{    int X, Y;​    Vector(int x,int y)        :X(x),Y(y){}​    Vector Add(const Vector&amp; other)const    {        return Vector(X + other.X, Y + other.Y); &nbsp; &nbsp; &nbsp;//在return里直接调用构造函数，代码非常简练    }​    Vector operator + (const Vector&amp; other)const    {        return Add(other); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//可以直接调用Add()    } &nbsp; &nbsp; &nbsp; &nbsp;bool operator == (const Vector&amp; other) const    {        return X == other.X &amp;&amp; Y == other.Y; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //简练，要记得这么写​    }    bool operator != (const Vector&amp; other) const    {        //return !operator==(other); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  //也对，但是比较奇怪        return !(*this == other); &nbsp; &nbsp;//使用重载过的== 操作符​    }​    std::ostream &amp; operator &lt;&lt; (std::ostream&amp; stream,const Vector&amp;other) &nbsp;const &nbsp; &nbsp; //重载&lt;&lt;运算符,这里提示函数参数过多    {        stream &lt;&lt; other.X &lt;&lt; “ “ &lt;&lt; other.Y &lt;&lt; std::endl;        return stream;    }​};​Vector v1(2, 3);Vector v2(1, 2);Vector result=v1 + v2;​std::cout &lt;&lt; result &lt;&lt; std::endl;c++</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/12/04/41-yun-suan-fu-ji-qi-chong-zai-in-c/"/>
      <url>/2023/12/04/41-yun-suan-fu-ji-qi-chong-zai-in-c/</url>
      
        <content type="html"><![CDATA[<h1 id="41-运算符及其重载-in-C"><a href="#41-运算符及其重载-in-C" class="headerlink" title="41 运算符及其重载 in C++"></a>41 运算符及其重载 in C++</h1><p>运算符是一种我们使用的一种符号，通常代替一个函数来执行一些事情。运算符就是一种函数。</p><p>重载：给运算符赋予新的含义，或者添加参数，或者创建。</p><p>重载<code>+</code>里调用了<code>Add()</code>函数，一般项目里都写上。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Vector</span></span><br><span class="line">{</span><br><span class="line"><span class="type">int</span> X, Y;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Vector</span>(<span class="type">int</span> x,<span class="type">int</span> y)</span><br><span class="line">:<span class="built_in">X</span>(x),<span class="built_in">Y</span>(y){}</span><br><span class="line"></span><br><span class="line"><span class="function">Vector <span class="title">Add</span><span class="params">(<span class="type">const</span> Vector&amp; other)</span><span class="type">const</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Vector</span>(X + other.X, Y + other.Y);      <span class="comment">//在return里直接调用构造函数，代码非常简练</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">Vector <span class="keyword">operator</span> + (<span class="type">const</span> Vector&amp; other)<span class="type">const</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Add</span>(other);                        <span class="comment">//可以直接调用Add()</span></span><br><span class="line">}</span><br><span class="line">    </span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> == (<span class="type">const</span> Vector&amp; other) <span class="type">const</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> X == other.X &amp;&amp; Y == other.Y;               <span class="comment">//简练，要记得这么写</span></span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> != (<span class="type">const</span> Vector&amp; other) <span class="type">const</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">//return !operator==(other);            //也对，但是比较奇怪</span></span><br><span class="line"><span class="keyword">return</span> !(*<span class="keyword">this</span> == other);    <span class="comment">//使用重载过的== 操作符</span></span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">std::ostream &amp; <span class="keyword">operator</span> &lt;&lt; (std::ostream&amp; stream,<span class="type">const</span> Vector&amp;other)  <span class="type">const</span>     <span class="comment">//重载&lt;&lt;运算符,这里提示函数参数过多</span></span><br><span class="line">{</span><br><span class="line">stream &lt;&lt; other.X &lt;&lt; <span class="string">" "</span> &lt;&lt; other.Y &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span> stream;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function">Vector <span class="title">v1</span><span class="params">(<span class="number">2</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line"><span class="function">Vector <span class="title">v2</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">Vector result=v1 + v2;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; result &lt;&lt; std::endl;</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/12/04/40-yin-shi-zhuan-huan-yu-explicit-guan-jian-zi/"/>
      <url>/2023/12/04/40-yin-shi-zhuan-huan-yu-explicit-guan-jian-zi/</url>
      
        <content type="html"><![CDATA[<h1 id="40-隐式转换与explicit关键字"><a href="#40-隐式转换与explicit关键字" class="headerlink" title="40 隐式转换与explicit关键字"></a>40 隐式转换与explicit关键字</h1><h2 id="Entity类"><a href="#Entity类" class="headerlink" title="Entity类"></a>Entity类</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">String m_Name;</span><br><span class="line"><span class="type">int</span> m_Age;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Entity</span>()</span><br><span class="line">:<span class="built_in">m_Name</span>(<span class="string">"Unknown"</span>),<span class="built_in">m_Age</span>(<span class="number">-1</span>){}</span><br><span class="line"></span><br><span class="line"><span class="built_in">Entity</span>(<span class="type">const</span> String&amp; name)</span><br><span class="line">:<span class="built_in">m_Name</span>(name),<span class="built_in">m_Age</span>(<span class="number">-1</span>){}</span><br><span class="line"></span><br><span class="line"><span class="built_in">Entity</span>(<span class="type">int</span> age)</span><br><span class="line">:<span class="built_in">m_Name</span>(<span class="string">"Unknown"</span>),<span class="built_in">m_Age</span>(age){}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">const</span> String&amp; <span class="title">GetName</span><span class="params">()</span><span class="type">const</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">return</span> m_Name;</span><br><span class="line">}</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h2 id="正常创建对象及实例化"><a href="#正常创建对象及实例化" class="headerlink" title="正常创建对象及实例化"></a>正常创建对象及实例化</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Entity <span class="title">a</span><span class="params">(<span class="string">"arya"</span>)</span></span>;      <span class="comment">// 调用第二个构造函数</span></span><br><span class="line"><span class="function">Entity <span class="title">b</span><span class="params">(<span class="number">22</span>)</span></span>;          <span class="comment">//调用第三个构造函数</span></span><br></pre></td></tr></tbody></table></figure><h2 id="涉及隐式转换的创建对象及实例化"><a href="#涉及隐式转换的创建对象及实例化" class="headerlink" title="涉及隐式转换的创建对象及实例化"></a>涉及隐式转换的创建对象及实例化</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Entity b = <span class="number">22</span>;</span><br></pre></td></tr></tbody></table></figure><p>隐式构造函数：将22转换成一个<code>Entity</code>，因为<code>Entity</code>类中有一个接受<code>int</code>类型参数的构造函数。</p><p>xxxxxxxxxx&nbsp;struct Vector{    int X, Y;​    Vector(int x,int y)        :X(x),Y(y){}​    Vector Add(const Vector&amp; other)const    {        return Vector(X + other.X, Y + other.Y); &nbsp; &nbsp; &nbsp;//在return里直接调用构造函数，代码非常简练    }​    Vector operator + (const Vector&amp; other)const    {        return Add(other); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//可以直接调用Add()    } &nbsp; &nbsp; &nbsp; &nbsp;bool operator == (const Vector&amp; other) const    {        return X == other.X &amp;&amp; Y == other.Y; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //简练，要记得这么写​    }    bool operator != (const Vector&amp; other) const    {        //return !operator==(other); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  //也对，但是比较奇怪        return !(*this == other); &nbsp; &nbsp;//使用重载过的== 操作符​    }​    std::ostream &amp; operator &lt;&lt; (std::ostream&amp; stream,const Vector&amp;other) &nbsp;const &nbsp; &nbsp; //重载&lt;&lt;运算符,这里提示函数参数过多    {        stream &lt;&lt; other.X &lt;&lt; “ “ &lt;&lt; other.Y &lt;&lt; std::endl;        return stream;    }​};​Vector v1(2, 3);Vector v2(1, 2);Vector result=v1 + v2;​std::cout &lt;&lt; result &lt;&lt; std::endl;c++</p><p>例如，<code>const char*</code>到 <code>string</code> 到 <code>Entity</code></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Entity a = <span class="string">"arya"</span>;     <span class="comment">//❌，因为“arya”是const char * 类型，到达Entity中间还有一步。</span></span><br><span class="line">Entity a = std::<span class="built_in">string</span>(<span class="string">"arya"</span>);     <span class="comment">//✔ ，string默认构造函数，将字符串显示转换为string类型，c++隐式的转换为Entity</span></span><br><span class="line">Entity a = <span class="built_in">Entity</span>(<span class="string">"arya"</span>);      <span class="comment">//✔，将const char *隐式转换为string,然后调用构造函数</span></span><br></pre></td></tr></tbody></table></figure><h2 id="explicit关键字：禁止隐式调用构造函数"><a href="#explicit关键字：禁止隐式调用构造函数" class="headerlink" title="explicit关键字：禁止隐式调用构造函数"></a>explicit关键字：禁止隐式调用构造函数</h2><p>C++编译器默认支持隐式转换的。有时需要禁止隐式转换，这就是<code>explicit</code>存在的意义。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">Entity</span><span class="params">(<span class="type">int</span> age)</span></span></span><br><span class="line"><span class="function">:m_Name(<span class="string">"Unknown"</span>),m_Age(age){</span>}</span><br><span class="line"></span><br><span class="line">Entity b = <span class="number">22</span>;         <span class="comment">//会报错，不能从int转换为Entity</span></span><br></pre></td></tr></tbody></table></figure><h3 id="总结：除非必要，可以不用隐式转换，就正常的创建对象及实例化。"><a href="#总结：除非必要，可以不用隐式转换，就正常的创建对象及实例化。" class="headerlink" title="总结：除非必要，可以不用隐式转换，就正常的创建对象及实例化。"></a>总结：除非必要，可以不用隐式转换，就正常的创建对象及实例化。</h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/12/04/39-new-guan-jian-zi-in-c/"/>
      <url>/2023/12/04/39-new-guan-jian-zi-in-c/</url>
      
        <content type="html"><![CDATA[<h1 id="39-new关键字-in-C"><a href="#39-new关键字-in-C" class="headerlink" title="39 new关键字 in C++"></a>39 new关键字 in C++</h1><h3 id="在编写c-程序语言时，应该关心内存、性能和优化问题。如果不在乎这些的话，真的不必使用这个语言，其他的语言会更简单方便。"><a href="#在编写c-程序语言时，应该关心内存、性能和优化问题。如果不在乎这些的话，真的不必使用这个语言，其他的语言会更简单方便。" class="headerlink" title="在编写c++程序语言时，应该关心内存、性能和优化问题。如果不在乎这些的话，真的不必使用这个语言，其他的语言会更简单方便。"></a>在编写c++程序语言时，应该关心内存、性能和优化问题。如果不在乎这些的话，真的不必使用这个语言，其他的语言会更简单方便。</h3><h2 id="new的主要目的是在堆上分配内存"><a href="#new的主要目的是在堆上分配内存" class="headerlink" title="new的主要目的是在堆上分配内存"></a>new的主要目的是在堆上分配内存</h2><h3 id="new-数据类型"><a href="#new-数据类型" class="headerlink" title="new  数据类型"></a><u><strong>new  数据类型</strong></u></h3><h4 id="无论是基本数据类型，还是类类型，还是数据）类型决定了在内存中会分配多大的空间。"><a href="#无论是基本数据类型，还是类类型，还是数据）类型决定了在内存中会分配多大的空间。" class="headerlink" title="无论是基本数据类型，还是类类型，还是数据）类型决定了在内存中会分配多大的空间。"></a>无论是基本数据类型，还是类类型，还是数据）类型决定了在内存中会分配多大的空间。</h4><h4 id="例如，new-int-向操作系统请求，给我一个4字节的连续的内存块，找到内存块后，返回一个指向这个内存的指针。这也可以看出，new比较消耗时间）"><a href="#例如，new-int-向操作系统请求，给我一个4字节的连续的内存块，找到内存块后，返回一个指向这个内存的指针。这也可以看出，new比较消耗时间）" class="headerlink" title="例如，new int ,向操作系统请求，给我一个4字节的连续的内存块，找到内存块后，返回一个指向这个内存的指针。这也可以看出，new比较消耗时间）"></a>例如，new int ,向操作系统请求，给我一个4字节的连续的内存块，找到内存块后，返回一个指向这个内存的指针。这也可以看出，new比较消耗时间）</h4><h2 id="new其实一种操作符，delete也是-要记得手动释放new分配的空间。"><a href="#new其实一种操作符，delete也是-要记得手动释放new分配的空间。" class="headerlink" title="new其实一种操作符，delete也是,要记得手动释放new分配的空间。"></a><u>new其实一种操作符，delete也是,要记得手动释放new分配的空间。</u></h2><h3 id="Entity类"><a href="#Entity类" class="headerlink" title="Entity类"></a>Entity类</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">String m_Name;</span><br><span class="line"><span class="type">int</span> m_Age;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Entity</span>()</span><br><span class="line">:<span class="built_in">m_Name</span>(<span class="string">"Unknown"</span>),<span class="built_in">m_Age</span>(<span class="number">-1</span>){}</span><br><span class="line"></span><br><span class="line"><span class="built_in">Entity</span>(<span class="type">const</span> String&amp; name)</span><br><span class="line">:<span class="built_in">m_Name</span>(name),<span class="built_in">m_Age</span>(<span class="number">-1</span>){}</span><br><span class="line"></span><br><span class="line"> <span class="built_in">Entity</span>(<span class="type">int</span> age)</span><br><span class="line">:<span class="built_in">m_Name</span>(<span class="string">"Unknown"</span>),<span class="built_in">m_Age</span>(age){}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">const</span> String&amp; <span class="title">GetName</span><span class="params">()</span><span class="type">const</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">return</span> m_Name;</span><br><span class="line">}</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="new-和delete操作符的使用"><a href="#new-和delete操作符的使用" class="headerlink" title="new 和delete操作符的使用"></a>new 和delete操作符的使用</h3><p>new在分配内存的同时，还可以调用构造函数。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">2</span>;   <span class="comment">//在栈上分配</span></span><br><span class="line"><span class="type">int</span>* b = <span class="keyword">new</span> <span class="type">int</span>;    <span class="comment">//在堆上分配4字节</span></span><br><span class="line"><span class="type">int</span>* c = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">2</span>];    <span class="comment">//在堆上分配数据，占内存4x2=8字节</span></span><br><span class="line"></span><br><span class="line">Entity* entity = <span class="keyword">new</span> Entity[<span class="number">5</span>]; <span class="comment">//分配数据</span></span><br><span class="line"></span><br><span class="line">Entity* entity2 = <span class="keyword">new</span> <span class="built_in">Entity</span>();    <span class="comment">//new不仅分配内存，还调用了构造函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> entity2;</span><br><span class="line"><span class="keyword">delete</span>[] entity;     <span class="comment">//释放数组</span></span><br><span class="line"><span class="keyword">delete</span>[] c;</span><br><span class="line"><span class="keyword">delete</span> b;</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/12/04/11-how-to-debug-c-vs/"/>
      <url>/2023/12/04/11-how-to-debug-c-vs/</url>
      
        <content type="html"><![CDATA[<h2 id="11-How-to-DEBUG-C-VS"><a href="#11-How-to-DEBUG-C-VS" class="headerlink" title="11 How to DEBUG C++ VS"></a>11 How to DEBUG C++ VS</h2><h3 id="Breakpoint"><a href="#Breakpoint" class="headerlink" title="Breakpoint"></a>Breakpoint</h3><p>设置断点</p><h1 id="Read-memory"><a href="#Read-memory" class="headerlink" title="Read memory"></a>Read memory</h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/12/02/hello-world/"/>
      <url>/2023/12/02/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><p>可以写东西嘛</p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
